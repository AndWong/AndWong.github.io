{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/solar-theme-hexo/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/images/earth.png","path":"images/earth.png","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/images/logo.png","path":"images/logo.png","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/images/mars.png","path":"images/mars.png","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/images/mercury.png","path":"images/mercury.png","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/images/shadow.png","path":"images/shadow.png","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/images/venus.png","path":"images/venus.png","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/images/jupiter.png","path":"images/jupiter.png","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/images/sun.png","path":"images/sun.png","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/justified-gallery/justifiedGallery.min.css","path":"lib/justified-gallery/justifiedGallery.min.css","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/images/Solar.png","path":"images/Solar.png","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/justified-gallery/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/jquery.justifiedGallery.min.js","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/styles.css","path":"lib/meslo-LG/styles.css","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Regular.ttf","modified":1,"renderable":1}],"Cache":[{"_id":"themes/solar-theme-hexo/_config.yml","hash":"3ed6cc43446d6bb3c6cf4e1a6df1f8a096256588","modified":1486819095852},{"_id":"themes/solar-theme-hexo/README.md","hash":"2ff73c09ebd6629da69d289f29849ab3047d948b","modified":1486815625213},{"_id":"themes/solar-theme-hexo/LICENSE","hash":"5ba0225e835bf8218d1524f481efc50c85447745","modified":1486815625213},{"_id":"source/_posts/Android事件分发机制的简单解读.md","hash":"5cf6c69cfa25bf9d428120b708f5001f70ae897b","modified":1486907158487},{"_id":"source/_posts/Android-SQLite的使用.md","hash":"f69a9e4a9a8aba24dfa3c776545a73601651498f","modified":1486991768323},{"_id":"source/_posts/Android设置全屏的几种方式.md","hash":"502f66fa2a24d18d36c9464172b3a821fa6349d3","modified":1486820198637},{"_id":"source/_posts/Android动态修改某个控件大小.md","hash":"98b5fab2742691574baff712f245b73b518d317c","modified":1486820205065},{"_id":"source/_posts/EditText相关.md","hash":"a8d926a6f57a0d42e178cf59c96af20beb01d257","modified":1486820196305},{"_id":"source/_posts/WebView-获取网页源码.md","hash":"27739108907bfcedbacdd79e9e611ec0dc2a53cb","modified":1486822011538},{"_id":"source/_posts/四大组件之Activity.md","hash":"6c3fe333a521f48fc32ef497dbe0cd0863ea66e3","modified":1487163453655},{"_id":"source/_posts/WiFi-Portal检测.md","hash":"ffc3b1933e58b3466869dce4a1d01d585d2a1153","modified":1486820703434},{"_id":"source/_posts/gitbub-blog.md","hash":"0ad8603c63663d492627dab75be03f67ee1e5f59","modified":1486906528855},{"_id":"themes/solar-theme-hexo/scripts/meta.js","hash":"fa6055a39851c9953d033e70c1614547b94dce60","modified":1486815625217},{"_id":"themes/solar-theme-hexo/scripts/thumbnail.js","hash":"df8829fd8c3119650037eba5ec11bdce06acff9d","modified":1486815625217},{"_id":"source/_posts/Android中Handler的简单终结.md","hash":"6a42c7fa550d77bbb6ae510a0f014d8ab73f0875","modified":1486909853319},{"_id":"themes/solar-theme-hexo/layout/layout.ejs","hash":"52b18d33641395aa85c1f099380ffe79eb8dd3e1","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/page.ejs","hash":"b6b7b1e6dc856a0e62f35da0151f67ba41143e04","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/post.ejs","hash":"2731e597b5d1714a6f5a775c432e99785f02a3e3","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/archive.ejs","hash":"f9c0434f023bdf2858aa8447137463c3224814be","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/index.ejs","hash":"0ea23cf9f01820a7e1c86600110afa876041cd25","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_extend.styl","hash":"2d360cc07d3cfe10fd95640346515f51fa0ea799","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_mixins.styl","hash":"c921ceb620deedddd38c9cec28190995e8764bab","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_util.styl","hash":"f8e286a21c7ec3e771d5ddeb2909ac92390af9bd","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_variables.styl","hash":"05dfdc680b2a156f615433a5978bf80178acb26f","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/style.styl","hash":"2b9c9697d30759cb3c49b52486b6fc34bcfbe464","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/images/earth.png","hash":"2cdcc68e36457410c633a578bb7b30a803193ecb","modified":1486815625225},{"_id":"themes/solar-theme-hexo/source/images/favicon-192x192.png","hash":"4b07282018db1888c7bc707a3e1b576c5684eabb","modified":1486815625225},{"_id":"themes/solar-theme-hexo/source/images/favicon.ico","hash":"54972e5dafeb73579b30c17232553c688d702448","modified":1486815625225},{"_id":"themes/solar-theme-hexo/source/images/logo.png","hash":"2084e1813f7310d9543a37608f4e6690d600b9c3","modified":1486815625229},{"_id":"themes/solar-theme-hexo/source/images/mars.png","hash":"4b33fb4ef0359cb401d4ed6d862caf55fb560802","modified":1486815625229},{"_id":"themes/solar-theme-hexo/source/images/mercury.png","hash":"e5ecda952ae568b8890026c7ab02a175652535a2","modified":1486815625229},{"_id":"themes/solar-theme-hexo/source/images/apple-touch-icon.png","hash":"bb91acbedda435287809e41148b1b255cdf957dc","modified":1486815625225},{"_id":"themes/solar-theme-hexo/source/images/shadow.png","hash":"ec5cfff7997edd1b5e01516604daca7c7a4f3788","modified":1486815625229},{"_id":"themes/solar-theme-hexo/source/js/main.js","hash":"481f730da10e5c9e1d59dfa9f1c0714ae709a0b8","modified":1486815625229},{"_id":"themes/solar-theme-hexo/source/images/venus.png","hash":"d45968836d952cd017439323135e6fad155c45ae","modified":1486815625229},{"_id":"themes/solar-theme-hexo/source/images/jupiter.png","hash":"4b7bc03b4cdf2fcde13e982aef340a1d385a3e7d","modified":1486815625229},{"_id":"themes/solar-theme-hexo/source/css/_partial/archive.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486815625221},{"_id":"themes/solar-theme-hexo/layout/_partial/banner.ejs","hash":"2611a9acb5392f425531610f5a12d396270041f7","modified":1486815625213},{"_id":"themes/solar-theme-hexo/layout/_partial/comments.ejs","hash":"853a4500da515ef3facc51a055886eaf8efd080d","modified":1486815625213},{"_id":"themes/solar-theme-hexo/layout/_partial/footer.ejs","hash":"7f6b3f126a58e6734b658ab57bc6b41822bc9342","modified":1486815625213},{"_id":"themes/solar-theme-hexo/layout/_partial/head.ejs","hash":"5b6f73a4fb96edde3005f90063509bf851714f72","modified":1486815625213},{"_id":"themes/solar-theme-hexo/layout/_partial/header.ejs","hash":"889fe54bbfd1fb3357e8c0614d57a437a72f782a","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/_partial/scripts.ejs","hash":"264e49c76744a2ce5be4cd69910cab8e0f517eda","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/layout/archive.ejs","hash":"f9c0434f023bdf2858aa8447137463c3224814be","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/layout/index.ejs","hash":"0ea23cf9f01820a7e1c86600110afa876041cd25","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/layout/layout.ejs","hash":"52b18d33641395aa85c1f099380ffe79eb8dd3e1","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/layout/page.ejs","hash":"b6b7b1e6dc856a0e62f35da0151f67ba41143e04","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/layout/post.ejs","hash":"2731e597b5d1714a6f5a775c432e99785f02a3e3","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_highlight/arta.styl","hash":"1a5accc115f41d1b669ed708ac6a29abac876599","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/kimbie.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/lightcode.styl","hash":"6c61c481836f6cbc3a57be10fa3af21bee83eb09","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/monokai.styl","hash":"5a4fe9f957fd7a368c21b62a818403db4270452f","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/paraiso.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/images/sun.png","hash":"62be3d54471271a1e8adb348a3f021ef001b4668","modified":1486815625229},{"_id":"themes/solar-theme-hexo/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_partial/article.styl","hash":"7bd68ecc8ebeb70daa74bfc179f984032eef18ae","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_partial/comments.styl","hash":"11fb41241a13971d23fc3f7e6d60315c7f248396","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_partial/footer.styl","hash":"b7570de60eaf9aa6b0192bf9c71b9172ff11bfbc","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_partial/header.styl","hash":"1545e8303fe36bbabb4da4a967c424de07d93dec","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_partial/index.styl","hash":"cf43702450ea1e5617541501886982a394cff8ec","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_partial/solar.styl","hash":"3af61c9b8033a4b804f0e1ba52525b55d6e16126","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/lib/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1486815625245},{"_id":"themes/solar-theme-hexo/source/images/Solar.png","hash":"463dbb952527b3d35c6203575eec552f62fd9d8e","modified":1486815625225},{"_id":"themes/solar-theme-hexo/source/lib/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1486815625245},{"_id":"themes/solar-theme-hexo/source/lib/jquery/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1486815625245},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/styles.css","hash":"eb88d0b9f1bbef99070e9627e2c96d892036bf7e","modified":1486815625297},{"_id":"themes/solar-theme-hexo/layout/_partial/post/actions_mobile.ejs","hash":"e7638a83e5aaa4bf5b24440ca76fec8eb563bed7","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/_partial/post/date.ejs","hash":"12a4a7ba6334e3e5c03d9a9601d7779a27c2e082","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/_partial/post/gallery.ejs","hash":"9aecd8908e8a684f33dc20c02497c0f1774137c7","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/_partial/post/share.ejs","hash":"25a3406f97e976ec13239f0d3f32f9e512511f50","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/_partial/post/tag.ejs","hash":"bfab03ef986d35ccad583f2d2b575db4a8d2789e","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/_partial/post/title.ejs","hash":"a060f1c6e3718494a6b1d0e1981ea0bf4e549828","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/css/_partial/post/actions_desktop.styl","hash":"ee37b3ef5bc3efa0e5795ca72de29ee1a316434f","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/css/_partial/post/actions_mobile.styl","hash":"d308fd8efe15cf089ec170873337cbabefae42ac","modified":1486815625221},{"_id":"themes/solar-theme-hexo/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1486815625229},{"_id":"themes/solar-theme-hexo/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1486815625229},{"_id":"themes/solar-theme-hexo/layout/_partial/post/actions_desktop.ejs","hash":"2319dea76f205c27dd59c994921f66350df8027a","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/layout/_partial/banner.ejs","hash":"f4359350f4b79b14a9d669055911d50d7a3dfd89","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/layout/_partial/comments.ejs","hash":"853a4500da515ef3facc51a055886eaf8efd080d","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/layout/_partial/footer.ejs","hash":"7f6b3f126a58e6734b658ab57bc6b41822bc9342","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1486815625233},{"_id":"themes/solar-theme-hexo/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1486815625241},{"_id":"themes/solar-theme-hexo/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1486815625233},{"_id":"themes/solar-theme-hexo/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1486815625245},{"_id":"themes/solar-theme-hexo/layout/layout/_partial/head.ejs","hash":"5b6f73a4fb96edde3005f90063509bf851714f72","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/layout/_partial/header.ejs","hash":"889fe54bbfd1fb3357e8c0614d57a437a72f782a","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/layout/_partial/scripts.ejs","hash":"264e49c76744a2ce5be4cd69910cab8e0f517eda","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1486815625241},{"_id":"themes/solar-theme-hexo/layout/layout/_partial/post/actions_desktop.ejs","hash":"2319dea76f205c27dd59c994921f66350df8027a","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/layout/_partial/post/actions_mobile.ejs","hash":"e7638a83e5aaa4bf5b24440ca76fec8eb563bed7","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/layout/_partial/post/date.ejs","hash":"12a4a7ba6334e3e5c03d9a9601d7779a27c2e082","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/layout/_partial/post/gallery.ejs","hash":"9aecd8908e8a684f33dc20c02497c0f1774137c7","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/layout/_partial/post/tag.ejs","hash":"bfab03ef986d35ccad583f2d2b575db4a8d2789e","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/layout/_partial/post/share.ejs","hash":"25a3406f97e976ec13239f0d3f32f9e512511f50","modified":1486815625217},{"_id":"themes/solar-theme-hexo/layout/layout/_partial/post/title.ejs","hash":"a060f1c6e3718494a6b1d0e1981ea0bf4e549828","modified":1486815625217},{"_id":"themes/solar-theme-hexo/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1486815625237},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1486815625293},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1486815625261},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1486815625277},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1486815625277},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1486815625285},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1486815625293},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1486815625253},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1486815625293},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1486815625269},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1486815625293},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1486815625297},{"_id":"themes/solar-theme-hexo/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1486815625297},{"_id":"public/2017/02/15/四大组件之Activity/index.html","hash":"e17af7c34b9a6a007f31fe62f1f222bd799e4929","modified":1487163489454},{"_id":"public/2017/02/13/Android-SQLite的使用/index.html","hash":"2012035c54b7070ed39bada6653533f3a9f49651","modified":1487163489454},{"_id":"public/2017/02/12/Android中Handler的简单终结/index.html","hash":"37147b1ffdde8d5e912df54de011e194dea31bba","modified":1487163489455},{"_id":"public/2017/02/12/Android事件分发机制的简单解读/index.html","hash":"189c27023fce135c0e2ca7a516d2e4f8edbf9886","modified":1487163489455},{"_id":"public/2017/02/11/WiFi-Portal检测/index.html","hash":"1ec3d1f64569a0e646ae759bad039bb6e64a41ee","modified":1487163489455},{"_id":"public/2017/02/10/WebView-获取网页源码/index.html","hash":"e07af3be4f80fde6ffaf7b7ab685adbbce505e99","modified":1487163489456},{"_id":"public/2017/02/10/Android设置全屏的几种方式/index.html","hash":"99b82d58add6fb4e2d7224e6b0031903db2f4b8a","modified":1487163489456},{"_id":"public/2017/01/21/EditText相关/index.html","hash":"24f9988c8b409173da800fa286b8d9dd32a1a547","modified":1487163489456},{"_id":"public/2017/01/10/Android动态修改某个控件大小/index.html","hash":"0d7e83e8d6ea1c96befd6db9a91f0750bc9f35c4","modified":1487163489456},{"_id":"public/2017/01/05/gitbub-blog/index.html","hash":"96543c1da3379696e22b3a76337cc0d0307450dc","modified":1487163489456},{"_id":"public/archives/index.html","hash":"0269ad236ba2ec96b3d859219c2e5f07f5cd8cb4","modified":1487163489456},{"_id":"public/archives/2017/index.html","hash":"cd05f22b2703367a783dbb45314146875e86eb5c","modified":1487163489456},{"_id":"public/archives/2017/01/index.html","hash":"6da5ce358cb33aa7704f953ee3e0c08b11cfd3ed","modified":1487163489456},{"_id":"public/archives/2017/02/index.html","hash":"c9a17605973abe6ea8bc7c0906f6473579dd41b2","modified":1487163489457},{"_id":"public/index.html","hash":"9e29c76e8bd131b2073f491ad6e0ca18750cace0","modified":1487163489457},{"_id":"public/tags/Android/index.html","hash":"5ea59d44b3053f479b4e27b30fe703b2d1c11ab3","modified":1487163489457},{"_id":"public/tags/四大组件之Activity/index.html","hash":"527c78cf13a2cc143198961bdf8aca0fde44485b","modified":1487163489457},{"_id":"public/tags/github/index.html","hash":"ad0f7178694e387838c63aad8205bf76eb28bbfc","modified":1487163489457},{"_id":"public/images/earth.png","hash":"2cdcc68e36457410c633a578bb7b30a803193ecb","modified":1487163489457},{"_id":"public/images/favicon-192x192.png","hash":"4b07282018db1888c7bc707a3e1b576c5684eabb","modified":1487163489457},{"_id":"public/images/favicon.ico","hash":"54972e5dafeb73579b30c17232553c688d702448","modified":1487163489457},{"_id":"public/images/logo.png","hash":"2084e1813f7310d9543a37608f4e6690d600b9c3","modified":1487163489458},{"_id":"public/images/mars.png","hash":"4b33fb4ef0359cb401d4ed6d862caf55fb560802","modified":1487163489458},{"_id":"public/images/mercury.png","hash":"e5ecda952ae568b8890026c7ab02a175652535a2","modified":1487163489459},{"_id":"public/images/apple-touch-icon.png","hash":"bb91acbedda435287809e41148b1b255cdf957dc","modified":1487163489459},{"_id":"public/images/shadow.png","hash":"ec5cfff7997edd1b5e01516604daca7c7a4f3788","modified":1487163489459},{"_id":"public/images/venus.png","hash":"d45968836d952cd017439323135e6fad155c45ae","modified":1487163491017},{"_id":"public/css/style.css","hash":"93e0d149c3dcee4650ba74445e954f46bb91d080","modified":1487163491033},{"_id":"public/images/jupiter.png","hash":"4b7bc03b4cdf2fcde13e982aef340a1d385a3e7d","modified":1487163491033},{"_id":"public/images/sun.png","hash":"62be3d54471271a1e8adb348a3f021ef001b4668","modified":1487163491036},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1487163491036},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1487163491036},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1487163491036},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1487163491036},{"_id":"public/js/main.js","hash":"481f730da10e5c9e1d59dfa9f1c0714ae709a0b8","modified":1487163491049},{"_id":"public/lib/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1487163491049},{"_id":"public/lib/meslo-LG/styles.css","hash":"eb88d0b9f1bbef99070e9627e2c96d892036bf7e","modified":1487163491049},{"_id":"public/lib/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1487163491049},{"_id":"public/lib/jquery/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1487163491049},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1487163491049},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1487163491049},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1487163491050},{"_id":"public/images/Solar.png","hash":"463dbb952527b3d35c6203575eec552f62fd9d8e","modified":1487163491062},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1487163491084},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1487163491108},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1487163491108},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1487163491109},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1487163491113},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1487163491113},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1487163491114},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1487163491114},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1487163491115},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1487163491115},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1487163491116},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1487163491116},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1487163491117}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Android事件分发机制的简单解读","date":"2017-02-12T12:52:44.000Z","_content":"本篇文章只是简单的终结Android中事件的分发机制便于记忆\n\n首先ViewGroup有onInterceptTouchEvent，dispatchTouchEvent和onTouchEvent方法\n而View有dispatchTouchEvent和onTouchEvent方法。\n\n每一个事件都是从ViewGroup开始，\n1.父控件ViewGroup先执行onInterceptTouchEvent（拦截），\n  onInterceptTouchEvent若返回true表示拦截则由该ViewGroup的onTouchEvent处理，\n  （其中onTouchEvent若返回true表示自身消费该事件，若onTouchEvent返回false则执行dispatchTouchEvent（向上反馈）给ViewGroup的父控件处理该onTouchEvent）\n  onInterceptTouchEvent若返回false表示不拦截则由该ViewGroup的dispatchTouchEvent（向下传递）给子控件（ViewGroup或View）处理。\n\n2.当事件传递到View控件时，先执行onTouchEvent事件，\n  其中onTouchEvent若返回true表示自身消费该事件，\n  若onTouchEvent返回false则执行dispatchTouchEvent（向上反馈）给父控件处理该onTouchEvent。\n","source":"_posts/Android事件分发机制的简单解读.md","raw":"---\ntitle: Android事件分发机制的简单解读\ndate: 2017-02-12 20:52:44\ntags: Android\n---\n本篇文章只是简单的终结Android中事件的分发机制便于记忆\n\n首先ViewGroup有onInterceptTouchEvent，dispatchTouchEvent和onTouchEvent方法\n而View有dispatchTouchEvent和onTouchEvent方法。\n\n每一个事件都是从ViewGroup开始，\n1.父控件ViewGroup先执行onInterceptTouchEvent（拦截），\n  onInterceptTouchEvent若返回true表示拦截则由该ViewGroup的onTouchEvent处理，\n  （其中onTouchEvent若返回true表示自身消费该事件，若onTouchEvent返回false则执行dispatchTouchEvent（向上反馈）给ViewGroup的父控件处理该onTouchEvent）\n  onInterceptTouchEvent若返回false表示不拦截则由该ViewGroup的dispatchTouchEvent（向下传递）给子控件（ViewGroup或View）处理。\n\n2.当事件传递到View控件时，先执行onTouchEvent事件，\n  其中onTouchEvent若返回true表示自身消费该事件，\n  若onTouchEvent返回false则执行dispatchTouchEvent（向上反馈）给父控件处理该onTouchEvent。\n","slug":"Android事件分发机制的简单解读","published":1,"updated":"2017-02-12T13:45:58.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6yqqwb0000yo2zln1v86fm","content":"<p>本篇文章只是简单的终结Android中事件的分发机制便于记忆</p>\n<p>首先ViewGroup有onInterceptTouchEvent，dispatchTouchEvent和onTouchEvent方法<br>而View有dispatchTouchEvent和onTouchEvent方法。</p>\n<p>每一个事件都是从ViewGroup开始，<br>1.父控件ViewGroup先执行onInterceptTouchEvent（拦截），<br>  onInterceptTouchEvent若返回true表示拦截则由该ViewGroup的onTouchEvent处理，<br>  （其中onTouchEvent若返回true表示自身消费该事件，若onTouchEvent返回false则执行dispatchTouchEvent（向上反馈）给ViewGroup的父控件处理该onTouchEvent）<br>  onInterceptTouchEvent若返回false表示不拦截则由该ViewGroup的dispatchTouchEvent（向下传递）给子控件（ViewGroup或View）处理。</p>\n<p>2.当事件传递到View控件时，先执行onTouchEvent事件，<br>  其中onTouchEvent若返回true表示自身消费该事件，<br>  若onTouchEvent返回false则执行dispatchTouchEvent（向上反馈）给父控件处理该onTouchEvent。</p>\n","excerpt":"","more":"<p>本篇文章只是简单的终结Android中事件的分发机制便于记忆</p>\n<p>首先ViewGroup有onInterceptTouchEvent，dispatchTouchEvent和onTouchEvent方法<br>而View有dispatchTouchEvent和onTouchEvent方法。</p>\n<p>每一个事件都是从ViewGroup开始，<br>1.父控件ViewGroup先执行onInterceptTouchEvent（拦截），<br>  onInterceptTouchEvent若返回true表示拦截则由该ViewGroup的onTouchEvent处理，<br>  （其中onTouchEvent若返回true表示自身消费该事件，若onTouchEvent返回false则执行dispatchTouchEvent（向上反馈）给ViewGroup的父控件处理该onTouchEvent）<br>  onInterceptTouchEvent若返回false表示不拦截则由该ViewGroup的dispatchTouchEvent（向下传递）给子控件（ViewGroup或View）处理。</p>\n<p>2.当事件传递到View控件时，先执行onTouchEvent事件，<br>  其中onTouchEvent若返回true表示自身消费该事件，<br>  若onTouchEvent返回false则执行dispatchTouchEvent（向上反馈）给父控件处理该onTouchEvent。</p>\n"},{"title":"Android SQLite的使用","date":"2017-02-13T12:34:42.000Z","_content":"Android自带的数据库SQLite，是一个轻量级便捷的数据库。\n\n1.创建\nAndroid SDK有一个抽象类SQLiteOpenHelper用于创建和升级数据库，\n所以继承SQLiteOpenHelper并实现其中的onCreate()和onUpgrade()即可创建和升级数据库。\n\n示例：\npublic class PskDBHelper extends SQLiteOpenHelper {\n\n    /**\n     * 构造方法，通常用这个就可以了\n     *\n     * @param context\n     * @param name    数据库名称 如： psk.db\n     * @param factory 数据库游标工厂 通常传入 null\n     * @param version 版本号 如：1\n     */\n    public PskDBHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {\n        super(context, name, factory, version);\n    }\n\n    @Override\n    public void onCreate(SQLiteDatabase db) {\n        //创建表SQL语句\n        //integer 表示整型，real 表示浮点型，text 表示文本类型，blob 表示二进制类型。\n        // 另外，primary key表示将id列设为主键，并用autoincrement关键字表示id列是自增长的。\n        String pskTable = \"create table psktable(_id integer primary key autoincrement,ssid text,bssid text,psk text)\";\n        db.execSQL(pskTable);\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\n    }\n}\n\n2.使用\n通过调用 pskDBHelper.getReadableDatabase() 和 pskDBHelper.getWritableDatabase()来获取 SQLiteDatabase 对象。\n其中如果getReadableDatabase()的数据库不存在则自动创建，存在则返回相应的对象，\n如果调用getWritableDatabase()的数据库不存在则会报错。\n\n3、增删改查\n这里只简单示例用SQL语句操作的方法。\n\n(1)插入数据\npublic void insert(SQLiteDatabase db) {\n    //插入数据SQL语句\n    String insertSQL = \"insert into psktable(ssid,bssid,psk) values('wong','20:6a:8a:68:81:ce','12345678')\";\n    //执行SQL语句\n    db.execSQL(insertSQL);\n}\n\n(2)删除数据\npublic void del(SQLiteDatabase db) {\n    //删除SQL语句\n    String sql = \"delete from psktable where _id = 1\";\n    //执行SQL语句\n    db.execSQL(sql);\n}\n\n(3)更新数据\npublic void update(SQLiteDatabase db) {\n    //修改SQL语句\n    String sql = \"update psktable set ssid = 'wong' where _id = 1\";\n    //执行SQL\n    db.execSQL(sql);\n}\n\n//在Android中查询数据是通过Cursor类来实现的，\n// 当我们使用SQLiteDatabase.query()方法时，\n// 会得到一个Cursor对象，Cursor指向的就是每一条数据\n(4)查询数据\npublic void search(SQLiteDatabase db) {\n    //查询获得游标\n    Cursor cursor = db.query(\"psktable\", null, null, null, null, null, null);\n    //判断游标是否为空\n    if (cursor.moveToFirst()) {\n        //遍历游标\n        for (int i = 0; i < cursor.getCount(); i++) {\n            cursor.move(i);\n            //获得ID\n            int id = cursor.getInt(0);\n            //获得ssid\n            String ssid = cursor.getString(1);\n            //获得bssid\n            String bssid = cursor.getString(2);\n            //获取psk\n            String psk = cursor.getString(3);\n        }\n    }\n}\n","source":"_posts/Android-SQLite的使用.md","raw":"---\ntitle: Android SQLite的使用\ndate: 2017-02-13 20:34:42\ntags: Android\n---\nAndroid自带的数据库SQLite，是一个轻量级便捷的数据库。\n\n1.创建\nAndroid SDK有一个抽象类SQLiteOpenHelper用于创建和升级数据库，\n所以继承SQLiteOpenHelper并实现其中的onCreate()和onUpgrade()即可创建和升级数据库。\n\n示例：\npublic class PskDBHelper extends SQLiteOpenHelper {\n\n    /**\n     * 构造方法，通常用这个就可以了\n     *\n     * @param context\n     * @param name    数据库名称 如： psk.db\n     * @param factory 数据库游标工厂 通常传入 null\n     * @param version 版本号 如：1\n     */\n    public PskDBHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {\n        super(context, name, factory, version);\n    }\n\n    @Override\n    public void onCreate(SQLiteDatabase db) {\n        //创建表SQL语句\n        //integer 表示整型，real 表示浮点型，text 表示文本类型，blob 表示二进制类型。\n        // 另外，primary key表示将id列设为主键，并用autoincrement关键字表示id列是自增长的。\n        String pskTable = \"create table psktable(_id integer primary key autoincrement,ssid text,bssid text,psk text)\";\n        db.execSQL(pskTable);\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\n    }\n}\n\n2.使用\n通过调用 pskDBHelper.getReadableDatabase() 和 pskDBHelper.getWritableDatabase()来获取 SQLiteDatabase 对象。\n其中如果getReadableDatabase()的数据库不存在则自动创建，存在则返回相应的对象，\n如果调用getWritableDatabase()的数据库不存在则会报错。\n\n3、增删改查\n这里只简单示例用SQL语句操作的方法。\n\n(1)插入数据\npublic void insert(SQLiteDatabase db) {\n    //插入数据SQL语句\n    String insertSQL = \"insert into psktable(ssid,bssid,psk) values('wong','20:6a:8a:68:81:ce','12345678')\";\n    //执行SQL语句\n    db.execSQL(insertSQL);\n}\n\n(2)删除数据\npublic void del(SQLiteDatabase db) {\n    //删除SQL语句\n    String sql = \"delete from psktable where _id = 1\";\n    //执行SQL语句\n    db.execSQL(sql);\n}\n\n(3)更新数据\npublic void update(SQLiteDatabase db) {\n    //修改SQL语句\n    String sql = \"update psktable set ssid = 'wong' where _id = 1\";\n    //执行SQL\n    db.execSQL(sql);\n}\n\n//在Android中查询数据是通过Cursor类来实现的，\n// 当我们使用SQLiteDatabase.query()方法时，\n// 会得到一个Cursor对象，Cursor指向的就是每一条数据\n(4)查询数据\npublic void search(SQLiteDatabase db) {\n    //查询获得游标\n    Cursor cursor = db.query(\"psktable\", null, null, null, null, null, null);\n    //判断游标是否为空\n    if (cursor.moveToFirst()) {\n        //遍历游标\n        for (int i = 0; i < cursor.getCount(); i++) {\n            cursor.move(i);\n            //获得ID\n            int id = cursor.getInt(0);\n            //获得ssid\n            String ssid = cursor.getString(1);\n            //获得bssid\n            String bssid = cursor.getString(2);\n            //获取psk\n            String psk = cursor.getString(3);\n        }\n    }\n}\n","slug":"Android-SQLite的使用","published":1,"updated":"2017-02-13T13:16:08.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6yqqwn0001yo2z3b3ut6vl","content":"<p>Android自带的数据库SQLite，是一个轻量级便捷的数据库。</p>\n<p>1.创建<br>Android SDK有一个抽象类SQLiteOpenHelper用于创建和升级数据库，<br>所以继承SQLiteOpenHelper并实现其中的onCreate()和onUpgrade()即可创建和升级数据库。</p>\n<p>示例：<br>public class PskDBHelper extends SQLiteOpenHelper {</p>\n<pre><code>/**\n * 构造方法，通常用这个就可以了\n *\n * @param context\n * @param name    数据库名称 如： psk.db\n * @param factory 数据库游标工厂 通常传入 null\n * @param version 版本号 如：1\n */\npublic PskDBHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {\n    super(context, name, factory, version);\n}\n\n@Override\npublic void onCreate(SQLiteDatabase db) {\n    //创建表SQL语句\n    //integer 表示整型，real 表示浮点型，text 表示文本类型，blob 表示二进制类型。\n    // 另外，primary key表示将id列设为主键，并用autoincrement关键字表示id列是自增长的。\n    String pskTable = &quot;create table psktable(_id integer primary key autoincrement,ssid text,bssid text,psk text)&quot;;\n    db.execSQL(pskTable);\n}\n\n@Override\npublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\n}\n</code></pre><p>}</p>\n<p>2.使用<br>通过调用 pskDBHelper.getReadableDatabase() 和 pskDBHelper.getWritableDatabase()来获取 SQLiteDatabase 对象。<br>其中如果getReadableDatabase()的数据库不存在则自动创建，存在则返回相应的对象，<br>如果调用getWritableDatabase()的数据库不存在则会报错。</p>\n<p>3、增删改查<br>这里只简单示例用SQL语句操作的方法。</p>\n<p>(1)插入数据<br>public void insert(SQLiteDatabase db) {<br>    //插入数据SQL语句<br>    String insertSQL = “insert into psktable(ssid,bssid,psk) values(‘wong’,’20:6a:8a:68:81:ce’,’12345678’)”;<br>    //执行SQL语句<br>    db.execSQL(insertSQL);<br>}</p>\n<p>(2)删除数据<br>public void del(SQLiteDatabase db) {<br>    //删除SQL语句<br>    String sql = “delete from psktable where _id = 1”;<br>    //执行SQL语句<br>    db.execSQL(sql);<br>}</p>\n<p>(3)更新数据<br>public void update(SQLiteDatabase db) {<br>    //修改SQL语句<br>    String sql = “update psktable set ssid = ‘wong’ where _id = 1”;<br>    //执行SQL<br>    db.execSQL(sql);<br>}</p>\n<p>//在Android中查询数据是通过Cursor类来实现的，<br>// 当我们使用SQLiteDatabase.query()方法时，<br>// 会得到一个Cursor对象，Cursor指向的就是每一条数据<br>(4)查询数据<br>public void search(SQLiteDatabase db) {<br>    //查询获得游标<br>    Cursor cursor = db.query(“psktable”, null, null, null, null, null, null);<br>    //判断游标是否为空<br>    if (cursor.moveToFirst()) {<br>        //遍历游标<br>        for (int i = 0; i &lt; cursor.getCount(); i++) {<br>            cursor.move(i);<br>            //获得ID<br>            int id = cursor.getInt(0);<br>            //获得ssid<br>            String ssid = cursor.getString(1);<br>            //获得bssid<br>            String bssid = cursor.getString(2);<br>            //获取psk<br>            String psk = cursor.getString(3);<br>        }<br>    }<br>}</p>\n","excerpt":"","more":"<p>Android自带的数据库SQLite，是一个轻量级便捷的数据库。</p>\n<p>1.创建<br>Android SDK有一个抽象类SQLiteOpenHelper用于创建和升级数据库，<br>所以继承SQLiteOpenHelper并实现其中的onCreate()和onUpgrade()即可创建和升级数据库。</p>\n<p>示例：<br>public class PskDBHelper extends SQLiteOpenHelper {</p>\n<pre><code>/**\n * 构造方法，通常用这个就可以了\n *\n * @param context\n * @param name    数据库名称 如： psk.db\n * @param factory 数据库游标工厂 通常传入 null\n * @param version 版本号 如：1\n */\npublic PskDBHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {\n    super(context, name, factory, version);\n}\n\n@Override\npublic void onCreate(SQLiteDatabase db) {\n    //创建表SQL语句\n    //integer 表示整型，real 表示浮点型，text 表示文本类型，blob 表示二进制类型。\n    // 另外，primary key表示将id列设为主键，并用autoincrement关键字表示id列是自增长的。\n    String pskTable = &quot;create table psktable(_id integer primary key autoincrement,ssid text,bssid text,psk text)&quot;;\n    db.execSQL(pskTable);\n}\n\n@Override\npublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\n}\n</code></pre><p>}</p>\n<p>2.使用<br>通过调用 pskDBHelper.getReadableDatabase() 和 pskDBHelper.getWritableDatabase()来获取 SQLiteDatabase 对象。<br>其中如果getReadableDatabase()的数据库不存在则自动创建，存在则返回相应的对象，<br>如果调用getWritableDatabase()的数据库不存在则会报错。</p>\n<p>3、增删改查<br>这里只简单示例用SQL语句操作的方法。</p>\n<p>(1)插入数据<br>public void insert(SQLiteDatabase db) {<br>    //插入数据SQL语句<br>    String insertSQL = “insert into psktable(ssid,bssid,psk) values(‘wong’,’20:6a:8a:68:81:ce’,’12345678’)”;<br>    //执行SQL语句<br>    db.execSQL(insertSQL);<br>}</p>\n<p>(2)删除数据<br>public void del(SQLiteDatabase db) {<br>    //删除SQL语句<br>    String sql = “delete from psktable where _id = 1”;<br>    //执行SQL语句<br>    db.execSQL(sql);<br>}</p>\n<p>(3)更新数据<br>public void update(SQLiteDatabase db) {<br>    //修改SQL语句<br>    String sql = “update psktable set ssid = ‘wong’ where _id = 1”;<br>    //执行SQL<br>    db.execSQL(sql);<br>}</p>\n<p>//在Android中查询数据是通过Cursor类来实现的，<br>// 当我们使用SQLiteDatabase.query()方法时，<br>// 会得到一个Cursor对象，Cursor指向的就是每一条数据<br>(4)查询数据<br>public void search(SQLiteDatabase db) {<br>    //查询获得游标<br>    Cursor cursor = db.query(“psktable”, null, null, null, null, null, null);<br>    //判断游标是否为空<br>    if (cursor.moveToFirst()) {<br>        //遍历游标<br>        for (int i = 0; i &lt; cursor.getCount(); i++) {<br>            cursor.move(i);<br>            //获得ID<br>            int id = cursor.getInt(0);<br>            //获得ssid<br>            String ssid = cursor.getString(1);<br>            //获得bssid<br>            String bssid = cursor.getString(2);<br>            //获取psk<br>            String psk = cursor.getString(3);<br>        }<br>    }<br>}</p>\n"},{"title":"Android设置全屏的几种方式","date":"2017-02-10T11:39:20.000Z","_content":"\n1. 将状态栏导航栏透明化，API19以上有效\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {\n    //透明状态栏\n    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);\n    //透明导航栏\n    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);\n}\n\n2. 设置全屏参数\ngetWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\n\n3. 沉浸式\n具体参照 ： http://blog.csdn.net/sinyu890807/article/details/51763825\nView decorView = getWindow().getDecorView();\nint option = View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;\ndecorView.setSystemUiVisibility(option);\n","source":"_posts/Android设置全屏的几种方式.md","raw":"---\ntitle: Android设置全屏的几种方式\ndate: 2017-02-10 19:39:20\ntags: Android\n---\n\n1. 将状态栏导航栏透明化，API19以上有效\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {\n    //透明状态栏\n    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);\n    //透明导航栏\n    getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);\n}\n\n2. 设置全屏参数\ngetWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\n\n3. 沉浸式\n具体参照 ： http://blog.csdn.net/sinyu890807/article/details/51763825\nView decorView = getWindow().getDecorView();\nint option = View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;\ndecorView.setSystemUiVisibility(option);\n","slug":"Android设置全屏的几种方式","published":1,"updated":"2017-02-11T13:36:38.637Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6yqqwz0003yo2zbagpsvtv","content":"<ol>\n<li><p>将状态栏导航栏透明化，API19以上有效<br>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {<br> //透明状态栏<br> getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);<br> //透明导航栏<br> getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);<br>}</p>\n</li>\n<li><p>设置全屏参数<br>getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);</p>\n</li>\n<li><p>沉浸式<br>具体参照 ： <a href=\"http://blog.csdn.net/sinyu890807/article/details/51763825\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/sinyu890807/article/details/51763825</a><br>View decorView = getWindow().getDecorView();<br>int option = View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;<br>decorView.setSystemUiVisibility(option);</p>\n</li>\n</ol>\n","excerpt":"","more":"<ol>\n<li><p>将状态栏导航栏透明化，API19以上有效<br>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {<br> //透明状态栏<br> getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);<br> //透明导航栏<br> getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);<br>}</p>\n</li>\n<li><p>设置全屏参数<br>getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);</p>\n</li>\n<li><p>沉浸式<br>具体参照 ： <a href=\"http://blog.csdn.net/sinyu890807/article/details/51763825\">http://blog.csdn.net/sinyu890807/article/details/51763825</a><br>View decorView = getWindow().getDecorView();<br>int option = View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;<br>decorView.setSystemUiVisibility(option);</p>\n</li>\n</ol>\n"},{"title":"Android动态修改某个控件大小","date":"2017-01-10T12:05:15.000Z","_content":"\n1. 动态修改Margin 和 大小\nViewGroup.LayoutParams layoutParams = (ViewGroup.LayoutParams)view.getLayoutParams();\nlayoutParams.topMargin= top; //像素px\nparlayoutParamsams.width = width;\nlayoutParams.height = height;\nview.setLayoutParams(layoutParams);\n\n2. 动态修改Padding\nview.setPadding(left,top,right,bottom);\n\n3. 动态修改TextView的drawable\nDrawable icon = getResources().getDrawable(R.mipmap.img);\nicon.setBounds(0,0,iconUp.getMinimumWidth(),iconUp.getMinimumHeight());\ntv.setCompoundDrawables(icon, null, null, null);\n","source":"_posts/Android动态修改某个控件大小.md","raw":"---\ntitle: Android动态修改某个控件大小\ndate: 2017-01-10 20:05:15\ntags: Android\n---\n\n1. 动态修改Margin 和 大小\nViewGroup.LayoutParams layoutParams = (ViewGroup.LayoutParams)view.getLayoutParams();\nlayoutParams.topMargin= top; //像素px\nparlayoutParamsams.width = width;\nlayoutParams.height = height;\nview.setLayoutParams(layoutParams);\n\n2. 动态修改Padding\nview.setPadding(left,top,right,bottom);\n\n3. 动态修改TextView的drawable\nDrawable icon = getResources().getDrawable(R.mipmap.img);\nicon.setBounds(0,0,iconUp.getMinimumWidth(),iconUp.getMinimumHeight());\ntv.setCompoundDrawables(icon, null, null, null);\n","slug":"Android动态修改某个控件大小","published":1,"updated":"2017-02-11T13:36:45.065Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6yqqx60004yo2z8fbdy6gu","content":"<ol>\n<li><p>动态修改Margin 和 大小<br>ViewGroup.LayoutParams layoutParams = (ViewGroup.LayoutParams)view.getLayoutParams();<br>layoutParams.topMargin= top; //像素px<br>parlayoutParamsams.width = width;<br>layoutParams.height = height;<br>view.setLayoutParams(layoutParams);</p>\n</li>\n<li><p>动态修改Padding<br>view.setPadding(left,top,right,bottom);</p>\n</li>\n<li><p>动态修改TextView的drawable<br>Drawable icon = getResources().getDrawable(R.mipmap.img);<br>icon.setBounds(0,0,iconUp.getMinimumWidth(),iconUp.getMinimumHeight());<br>tv.setCompoundDrawables(icon, null, null, null);</p>\n</li>\n</ol>\n","excerpt":"","more":"<ol>\n<li><p>动态修改Margin 和 大小<br>ViewGroup.LayoutParams layoutParams = (ViewGroup.LayoutParams)view.getLayoutParams();<br>layoutParams.topMargin= top; //像素px<br>parlayoutParamsams.width = width;<br>layoutParams.height = height;<br>view.setLayoutParams(layoutParams);</p>\n</li>\n<li><p>动态修改Padding<br>view.setPadding(left,top,right,bottom);</p>\n</li>\n<li><p>动态修改TextView的drawable<br>Drawable icon = getResources().getDrawable(R.mipmap.img);<br>icon.setBounds(0,0,iconUp.getMinimumWidth(),iconUp.getMinimumHeight());<br>tv.setCompoundDrawables(icon, null, null, null);</p>\n</li>\n</ol>\n"},{"title":"EditText相关","date":"2017-01-21T12:07:11.000Z","_content":"1.光标\nx_count.setCursorVisible(true); //设置光标\ntx_count.setSelection(tx_count.length()); //设置光标位置\n\n2.自动弹窗软键盘\ntx_count.requestFocus();\nInputMethodManager imm = (InputMethodManager) tx_count.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);\nimm.toggleSoftInput(0, InputMethodManager.SHOW_FORCED);\n\n3.输入监听\ntx_count.addTextChangedListener(new TextWatcher() {\n    @Override\n    public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n    }\n    @Override\n    public void onTextChanged(CharSequence s, int start, int before, int count) {\n    }\n    @Override\n    public void afterTextChanged(Editable s) {\n    }\n});\n\n4.xml:\nandroid:inputType=\"phone\" //输入类型\nandroid:digits=\"0123456789.\" //只能输入数字和点\nandroid:background=\"@null\" //背景为空\nandroid:cursorVisible=\"false\" //不显示光标\nandroid:maxLength=\"5\" //5个字符\n\n5.AndroidManifest.xml\nandroid:windowSoftInputMode=\"stateHidden|stateAlwaysHidden\"  //不弹出软键盘\nandroid:windowSoftInputMode=\"stateVisible|stateAlwaysVisible\"  //自动弹出软键盘\n","source":"_posts/EditText相关.md","raw":"---\ntitle: EditText相关\ndate: 2017-01-21 20:07:11\ntags: Android\n---\n1.光标\nx_count.setCursorVisible(true); //设置光标\ntx_count.setSelection(tx_count.length()); //设置光标位置\n\n2.自动弹窗软键盘\ntx_count.requestFocus();\nInputMethodManager imm = (InputMethodManager) tx_count.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);\nimm.toggleSoftInput(0, InputMethodManager.SHOW_FORCED);\n\n3.输入监听\ntx_count.addTextChangedListener(new TextWatcher() {\n    @Override\n    public void beforeTextChanged(CharSequence s, int start, int count, int after) {\n    }\n    @Override\n    public void onTextChanged(CharSequence s, int start, int before, int count) {\n    }\n    @Override\n    public void afterTextChanged(Editable s) {\n    }\n});\n\n4.xml:\nandroid:inputType=\"phone\" //输入类型\nandroid:digits=\"0123456789.\" //只能输入数字和点\nandroid:background=\"@null\" //背景为空\nandroid:cursorVisible=\"false\" //不显示光标\nandroid:maxLength=\"5\" //5个字符\n\n5.AndroidManifest.xml\nandroid:windowSoftInputMode=\"stateHidden|stateAlwaysHidden\"  //不弹出软键盘\nandroid:windowSoftInputMode=\"stateVisible|stateAlwaysVisible\"  //自动弹出软键盘\n","slug":"EditText相关","published":1,"updated":"2017-02-11T13:36:36.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6yqqxb0005yo2zbvs4alww","content":"<p>1.光标<br>x_count.setCursorVisible(true); //设置光标<br>tx_count.setSelection(tx_count.length()); //设置光标位置</p>\n<p>2.自动弹窗软键盘<br>tx_count.requestFocus();<br>InputMethodManager imm = (InputMethodManager) tx_count.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);<br>imm.toggleSoftInput(0, InputMethodManager.SHOW_FORCED);</p>\n<p>3.输入监听<br>tx_count.addTextChangedListener(new TextWatcher() {<br>    @Override<br>    public void beforeTextChanged(CharSequence s, int start, int count, int after) {<br>    }<br>    @Override<br>    public void onTextChanged(CharSequence s, int start, int before, int count) {<br>    }<br>    @Override<br>    public void afterTextChanged(Editable s) {<br>    }<br>});</p>\n<p>4.xml:<br>android:inputType=”phone” //输入类型<br>android:digits=”0123456789.” //只能输入数字和点<br>android:background=”@null” //背景为空<br>android:cursorVisible=”false” //不显示光标<br>android:maxLength=”5” //5个字符</p>\n<p>5.AndroidManifest.xml<br>android:windowSoftInputMode=”stateHidden|stateAlwaysHidden”  //不弹出软键盘<br>android:windowSoftInputMode=”stateVisible|stateAlwaysVisible”  //自动弹出软键盘</p>\n","excerpt":"","more":"<p>1.光标<br>x_count.setCursorVisible(true); //设置光标<br>tx_count.setSelection(tx_count.length()); //设置光标位置</p>\n<p>2.自动弹窗软键盘<br>tx_count.requestFocus();<br>InputMethodManager imm = (InputMethodManager) tx_count.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);<br>imm.toggleSoftInput(0, InputMethodManager.SHOW_FORCED);</p>\n<p>3.输入监听<br>tx_count.addTextChangedListener(new TextWatcher() {<br>    @Override<br>    public void beforeTextChanged(CharSequence s, int start, int count, int after) {<br>    }<br>    @Override<br>    public void onTextChanged(CharSequence s, int start, int before, int count) {<br>    }<br>    @Override<br>    public void afterTextChanged(Editable s) {<br>    }<br>});</p>\n<p>4.xml:<br>android:inputType=”phone” //输入类型<br>android:digits=”0123456789.” //只能输入数字和点<br>android:background=”@null” //背景为空<br>android:cursorVisible=”false” //不显示光标<br>android:maxLength=”5” //5个字符</p>\n<p>5.AndroidManifest.xml<br>android:windowSoftInputMode=”stateHidden|stateAlwaysHidden”  //不弹出软键盘<br>android:windowSoftInputMode=”stateVisible|stateAlwaysVisible”  //自动弹出软键盘</p>\n"},{"title":"WebView 获取网页源码","date":"2017-02-10T11:59:27.000Z","_content":"Android在WebView中获取网页源码  \n\n在Api-19以上获取源码的方式有修改，如下：\n  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {\n    mWebView.evaluateJavascript(\n            \"(function() {return ('<html>'+document.getElementsByTagName('html')[0].innerHTML+'</html>');})();\",\n              new ValueCallback<String>() {\n                @Override\n                public void onReceiveValue(String html) {\n                    Log.d(\"HTML\", \"whd >>html:\" + html);\n                }\n            });\n  }\n\n在Api-19以下获取源码的方式，如下：          \n1. 使能javascript：\nwebView.getSettings().setJavaScriptEnabled(true);\n\n2. 编写本地接口\nfinal class InJavaScriptLocalObj {\n    public void showSource(String html) {\n        Log.d(\"HTML\", html);\n    }\n}\n\n3. 向网页暴露本地接口\nwebView.addJavascriptInterface(new InJavaScriptLocalObj(), \"local_obj\");\n\n4. 编写自己的WebViewClient，并在onPageFinished中提取网页源码。\nfinal class MyWebViewClient extends WebViewClient{   \n    public boolean shouldOverrideUrlLoading(WebView view, String url) {    \n        view.loadUrl(url);    \n        return true;    \n    }   \n    public void onPageStarted(WebView view, String url, Bitmap favicon) {\n        Log.d(\"WebView\",\"onPageStarted\"); window.imagelistner.getImage(this.src)\n        super.onPageStarted(view, url, favicon);\n    }     \n    public void onPageFinished(WebView view, String url) {\n        Log.d(\"WebView\",\"onPageFinished \");\n        view.loadUrl(\"javascript:window.local_obj.showSource('<head>'+\" +\n                \"document.getElementsByTagName('html')[0].innerHTML+'</head>');\");\n        super.onPageFinished(view, url);\n    }\n}\n关键之处在于：\nview.loadUrl(\"javascript:window.local_obj.showSource('<head>'+document.getElementsByTagName('html')[0].innerHTML+'</head>');\");\n运行，可以看到在showSource(String html)中打印了网页源码。\n","source":"_posts/WebView-获取网页源码.md","raw":"---\ntitle: WebView 获取网页源码\ndate: 2017-02-10 19:59:27\ntags: Android\n---\nAndroid在WebView中获取网页源码  \n\n在Api-19以上获取源码的方式有修改，如下：\n  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {\n    mWebView.evaluateJavascript(\n            \"(function() {return ('<html>'+document.getElementsByTagName('html')[0].innerHTML+'</html>');})();\",\n              new ValueCallback<String>() {\n                @Override\n                public void onReceiveValue(String html) {\n                    Log.d(\"HTML\", \"whd >>html:\" + html);\n                }\n            });\n  }\n\n在Api-19以下获取源码的方式，如下：          \n1. 使能javascript：\nwebView.getSettings().setJavaScriptEnabled(true);\n\n2. 编写本地接口\nfinal class InJavaScriptLocalObj {\n    public void showSource(String html) {\n        Log.d(\"HTML\", html);\n    }\n}\n\n3. 向网页暴露本地接口\nwebView.addJavascriptInterface(new InJavaScriptLocalObj(), \"local_obj\");\n\n4. 编写自己的WebViewClient，并在onPageFinished中提取网页源码。\nfinal class MyWebViewClient extends WebViewClient{   \n    public boolean shouldOverrideUrlLoading(WebView view, String url) {    \n        view.loadUrl(url);    \n        return true;    \n    }   \n    public void onPageStarted(WebView view, String url, Bitmap favicon) {\n        Log.d(\"WebView\",\"onPageStarted\"); window.imagelistner.getImage(this.src)\n        super.onPageStarted(view, url, favicon);\n    }     \n    public void onPageFinished(WebView view, String url) {\n        Log.d(\"WebView\",\"onPageFinished \");\n        view.loadUrl(\"javascript:window.local_obj.showSource('<head>'+\" +\n                \"document.getElementsByTagName('html')[0].innerHTML+'</head>');\");\n        super.onPageFinished(view, url);\n    }\n}\n关键之处在于：\nview.loadUrl(\"javascript:window.local_obj.showSource('<head>'+document.getElementsByTagName('html')[0].innerHTML+'</head>');\");\n运行，可以看到在showSource(String html)中打印了网页源码。\n","slug":"WebView-获取网页源码","published":1,"updated":"2017-02-11T14:06:51.538Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6yqqxk0008yo2zn5jdaluj","content":"<p>Android在WebView中获取网页源码  </p>\n<p>在Api-19以上获取源码的方式有修改，如下：<br>  if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {<br>    mWebView.evaluateJavascript(<br>            “(function() {return (‘<html>‘+document.getElementsByTagName(‘html’)[0].innerHTML+’</html>‘);})();”,<br>              new ValueCallback<string>() {<br>                @Override<br>                public void onReceiveValue(String html) {<br>                    Log.d(“HTML”, “whd &gt;&gt;html:” + html);<br>                }<br>            });<br>  }</string></p>\n<p>在Api-19以下获取源码的方式，如下：          </p>\n<ol>\n<li><p>使能javascript：<br>webView.getSettings().setJavaScriptEnabled(true);</p>\n</li>\n<li><p>编写本地接口<br>final class InJavaScriptLocalObj {<br> public void showSource(String html) {</p>\n<pre><code>Log.d(&quot;HTML&quot;, html);\n</code></pre><p> }<br>}</p>\n</li>\n<li><p>向网页暴露本地接口<br>webView.addJavascriptInterface(new InJavaScriptLocalObj(), “local_obj”);</p>\n</li>\n<li><p>编写自己的WebViewClient，并在onPageFinished中提取网页源码。<br>final class MyWebViewClient extends WebViewClient{<br> public boolean shouldOverrideUrlLoading(WebView view, String url) {    </p>\n<pre><code>view.loadUrl(url);    \nreturn true;    \n</code></pre><p> }<br> public void onPageStarted(WebView view, String url, Bitmap favicon) {</p>\n<pre><code>Log.d(&quot;WebView&quot;,&quot;onPageStarted&quot;); window.imagelistner.getImage(this.src)\nsuper.onPageStarted(view, url, favicon);\n</code></pre><p> }<br> public void onPageFinished(WebView view, String url) {</p>\n<pre><code>Log.d(&quot;WebView&quot;,&quot;onPageFinished &quot;);\nview.loadUrl(&quot;javascript:window.local_obj.showSource(&apos;&lt;head&gt;&apos;+&quot; +\n        &quot;document.getElementsByTagName(&apos;html&apos;)[0].innerHTML+&apos;&lt;/head&gt;&apos;);&quot;);\nsuper.onPageFinished(view, url);\n</code></pre><p> }<br>}<br>关键之处在于：<br>view.loadUrl(“javascript:window.local_obj.showSource(‘<head>‘+document.getElementsByTagName(‘html’)[0].innerHTML+’</head>‘);”);<br>运行，可以看到在showSource(String html)中打印了网页源码。</p>\n</li>\n</ol>\n","excerpt":"","more":"<p>Android在WebView中获取网页源码  </p>\n<p>在Api-19以上获取源码的方式有修改，如下：<br>  if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {<br>    mWebView.evaluateJavascript(<br>            “(function() {return (‘<html>‘+document.getElementsByTagName(‘html’)[0].innerHTML+’</html>‘);})();”,<br>              new ValueCallback<String>() {<br>                @Override<br>                public void onReceiveValue(String html) {<br>                    Log.d(“HTML”, “whd &gt;&gt;html:” + html);<br>                }<br>            });<br>  }</p>\n<p>在Api-19以下获取源码的方式，如下：          </p>\n<ol>\n<li><p>使能javascript：<br>webView.getSettings().setJavaScriptEnabled(true);</p>\n</li>\n<li><p>编写本地接口<br>final class InJavaScriptLocalObj {<br> public void showSource(String html) {</p>\n<pre><code>Log.d(&quot;HTML&quot;, html);\n</code></pre><p> }<br>}</p>\n</li>\n<li><p>向网页暴露本地接口<br>webView.addJavascriptInterface(new InJavaScriptLocalObj(), “local_obj”);</p>\n</li>\n<li><p>编写自己的WebViewClient，并在onPageFinished中提取网页源码。<br>final class MyWebViewClient extends WebViewClient{<br> public boolean shouldOverrideUrlLoading(WebView view, String url) {    </p>\n<pre><code>view.loadUrl(url);    \nreturn true;    \n</code></pre><p> }<br> public void onPageStarted(WebView view, String url, Bitmap favicon) {</p>\n<pre><code>Log.d(&quot;WebView&quot;,&quot;onPageStarted&quot;); window.imagelistner.getImage(this.src)\nsuper.onPageStarted(view, url, favicon);\n</code></pre><p> }<br> public void onPageFinished(WebView view, String url) {</p>\n<pre><code>Log.d(&quot;WebView&quot;,&quot;onPageFinished &quot;);\nview.loadUrl(&quot;javascript:window.local_obj.showSource(&apos;&lt;head&gt;&apos;+&quot; +\n        &quot;document.getElementsByTagName(&apos;html&apos;)[0].innerHTML+&apos;&lt;/head&gt;&apos;);&quot;);\nsuper.onPageFinished(view, url);\n</code></pre><p> }<br>}<br>关键之处在于：<br>view.loadUrl(“javascript:window.local_obj.showSource(‘<head>‘+document.getElementsByTagName(‘html’)[0].innerHTML+’</head>‘);”);<br>运行，可以看到在showSource(String html)中打印了网页源码。</p>\n</li>\n</ol>\n"},{"title":"四大组件之Activity","date":"2017-02-15T11:48:09.000Z","_content":"\nActivity乃Andoid四大组件中的一个，主要负责用户界面的展示和用户交互处理。\n\n1.生命周期\n正常的一次启动到结束 ：onCreate -> onStart -> onResume -> onPause -> onStop -> onDestory\n\n切换到后台 : onPause -> onStop\n从后台回来 : onRestart ->onStart -> onResume\n\n从A切到B ： A-onPause -> B-onCreate -> B-onStart -> B-onResume -> A-onStop\n从B返回A ： B-onPause -> A-onRestart -> A-onStart -> A-onResume -> B-onStop -> B-onDestroy\n\n横竖屏切换 ： onSaveInstanceState -> onPause -> onStop -> onDestory -> onCreate -> onStart -> onRestoreInstanceState -> onResume\n\n2.启动模式\n（在AndroidManifest.xml中的android:launchMode=\"singleTask\"配置）\n (1)standard : 默认的标准模式，每次启动Activity都会创建Activity并放人Task栈中\n (2)singleTop ：当要启动的Activity刚好在Task栈的栈顶时使用这个，否则重新创建一个\n (3)singleTask ： 只要Task栈中存在就使用，并把该Activity以上的其他Actitity弹出栈中\n (4)singleInstance ： 只要在该Activity存在Task栈中，如何应用启动都可以直接调用\n\n3.闪屏页的快速启动\n4.如何禁止横竖屏切换生命周期变换\n5.Activity设置为首页Activity\n6.启动Actitiy的几种方式\n","source":"_posts/四大组件之Activity.md","raw":"---\ntitle: 四大组件之Activity\ndate: 2017-02-15 19:48:09\ntags: 四大组件之Activity\n---\n\nActivity乃Andoid四大组件中的一个，主要负责用户界面的展示和用户交互处理。\n\n1.生命周期\n正常的一次启动到结束 ：onCreate -> onStart -> onResume -> onPause -> onStop -> onDestory\n\n切换到后台 : onPause -> onStop\n从后台回来 : onRestart ->onStart -> onResume\n\n从A切到B ： A-onPause -> B-onCreate -> B-onStart -> B-onResume -> A-onStop\n从B返回A ： B-onPause -> A-onRestart -> A-onStart -> A-onResume -> B-onStop -> B-onDestroy\n\n横竖屏切换 ： onSaveInstanceState -> onPause -> onStop -> onDestory -> onCreate -> onStart -> onRestoreInstanceState -> onResume\n\n2.启动模式\n（在AndroidManifest.xml中的android:launchMode=\"singleTask\"配置）\n (1)standard : 默认的标准模式，每次启动Activity都会创建Activity并放人Task栈中\n (2)singleTop ：当要启动的Activity刚好在Task栈的栈顶时使用这个，否则重新创建一个\n (3)singleTask ： 只要Task栈中存在就使用，并把该Activity以上的其他Actitity弹出栈中\n (4)singleInstance ： 只要在该Activity存在Task栈中，如何应用启动都可以直接调用\n\n3.闪屏页的快速启动\n4.如何禁止横竖屏切换生命周期变换\n5.Activity设置为首页Activity\n6.启动Actitiy的几种方式\n","slug":"四大组件之Activity","published":1,"updated":"2017-02-15T12:57:33.655Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6yqqxq000ayo2zoc84y6c5","content":"<p>Activity乃Andoid四大组件中的一个，主要负责用户界面的展示和用户交互处理。</p>\n<p>1.生命周期<br>正常的一次启动到结束 ：onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestory</p>\n<p>切换到后台 : onPause -&gt; onStop<br>从后台回来 : onRestart -&gt;onStart -&gt; onResume</p>\n<p>从A切到B ： A-onPause -&gt; B-onCreate -&gt; B-onStart -&gt; B-onResume -&gt; A-onStop<br>从B返回A ： B-onPause -&gt; A-onRestart -&gt; A-onStart -&gt; A-onResume -&gt; B-onStop -&gt; B-onDestroy</p>\n<p>横竖屏切换 ： onSaveInstanceState -&gt; onPause -&gt; onStop -&gt; onDestory -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p>\n<p>2.启动模式<br>（在AndroidManifest.xml中的android:launchMode=”singleTask”配置）<br> (1)standard : 默认的标准模式，每次启动Activity都会创建Activity并放人Task栈中<br> (2)singleTop ：当要启动的Activity刚好在Task栈的栈顶时使用这个，否则重新创建一个<br> (3)singleTask ： 只要Task栈中存在就使用，并把该Activity以上的其他Actitity弹出栈中<br> (4)singleInstance ： 只要在该Activity存在Task栈中，如何应用启动都可以直接调用</p>\n<p>3.闪屏页的快速启动<br>4.如何禁止横竖屏切换生命周期变换<br>5.Activity设置为首页Activity<br>6.启动Actitiy的几种方式</p>\n","excerpt":"","more":"<p>Activity乃Andoid四大组件中的一个，主要负责用户界面的展示和用户交互处理。</p>\n<p>1.生命周期<br>正常的一次启动到结束 ：onCreate -&gt; onStart -&gt; onResume -&gt; onPause -&gt; onStop -&gt; onDestory</p>\n<p>切换到后台 : onPause -&gt; onStop<br>从后台回来 : onRestart -&gt;onStart -&gt; onResume</p>\n<p>从A切到B ： A-onPause -&gt; B-onCreate -&gt; B-onStart -&gt; B-onResume -&gt; A-onStop<br>从B返回A ： B-onPause -&gt; A-onRestart -&gt; A-onStart -&gt; A-onResume -&gt; B-onStop -&gt; B-onDestroy</p>\n<p>横竖屏切换 ： onSaveInstanceState -&gt; onPause -&gt; onStop -&gt; onDestory -&gt; onCreate -&gt; onStart -&gt; onRestoreInstanceState -&gt; onResume</p>\n<p>2.启动模式<br>（在AndroidManifest.xml中的android:launchMode=”singleTask”配置）<br> (1)standard : 默认的标准模式，每次启动Activity都会创建Activity并放人Task栈中<br> (2)singleTop ：当要启动的Activity刚好在Task栈的栈顶时使用这个，否则重新创建一个<br> (3)singleTask ： 只要Task栈中存在就使用，并把该Activity以上的其他Actitity弹出栈中<br> (4)singleInstance ： 只要在该Activity存在Task栈中，如何应用启动都可以直接调用</p>\n<p>3.闪屏页的快速启动<br>4.如何禁止横竖屏切换生命周期变换<br>5.Activity设置为首页Activity<br>6.启动Actitiy的几种方式</p>\n"},{"title":"WiFi Portal检测","date":"2017-02-11T13:35:53.000Z","_content":"WiFi连接上一个开放热点，如何判断是否需要登录认证？\n\n首先当我们发送一个request请求时，我们得到的response总是会携带一个HTTP状态码（除非请求超时）。WiFi portal同样也要遵循这样的规则，WiFi portal拦截网络请求时，返回给我们一个response（内容是登陆页面）。我们的这次请求虽然被拦截了，但是无疑他是一个成功的请求，也就是说response携带的状态码应该是 200 。这时，我们与服务器端商定一个请求链接http ://www.xx.com/genera_204，固定返回一个状态码 204。当网络状态发生变化时候，我们就去请求这个链接。如果我们的response携带的状态码是204说明我们请求成功，如果我们得到的是200，说明需要进行WiFi 验证。\n这个方法来自Android4.0.1AOSP源码 WifiWatchdogStateMachine#isWalledGardenConnection()。\n\n对于个人开发者或者“小厂商”不建议在我们自己的服务器上处理http ://www.xxx.com/generate_204，除非你家的服务器很稳定，基本上不出现问题。这时候我们可以考虑下“大厂商”是否已经有类似的功能。像UC啊什么的。他们都能自动提醒你网络需要登陆，他们也是使用了同样的方式，至于链接地址，就靠大家自己了。\n\n代码如下：\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport android.os.AsyncTask;\n/**\n * 检测wifi是否需要登陆\n * 使用方式：\n * NetNeedLoginCheckUtil.needLoginNetworkCheck(new NeedLoginCallBack() {\n *  @Override\n *  public void needLogin(boolean needLogin) {\n *     if (needLogin) {\n *          wifi 需要登陆\n *     }\n *  }\n * });\n **/\n public class NetNeedLoginCheckUtil extends AsyncTask<Integer, Integer, Boolean>{\n    NeedLoginCallBack callBack;\n    public NetNeedLoginCheckUtil(NeedLoginCallBack callBack) {\n        super();\n        this.callBack = callBack;\n    }    \n    @Override\n    protected Boolean doInBackground(Integer... params) {\n        return isWifiSetPortal();\n    }    \n    @Override\n    protected void onPostExecute(Boolean result) {\n        if (callBack != null) {\n            callBack.needLogin(result);\n        }\n    }\n    private boolean isWifiSetPortal() {  \n        final String mWalledGardenUrl = \"http://connect.rom.miui.com/generate_204\";  \n        final int WALLED_GARDEN_SOCKET_TIMEOUT_MS = 10000;  \n        HttpURLConnection urlConnection = null;  \n        try {  \n            URL url = new URL(mWalledGardenUrl);  \n            urlConnection = (HttpURLConnection) url.openConnection();  \n            urlConnection.setInstanceFollowRedirects(false);  \n            urlConnection.setConnectTimeout(WALLED_GARDEN_SOCKET_TIMEOUT_MS);  \n            urlConnection.setReadTimeout(WALLED_GARDEN_SOCKET_TIMEOUT_MS);  \n            urlConnection.setUseCaches(false);  \n            urlConnection.getInputStream();  \n            return urlConnection.getResponseCode() != 204;  \n        } catch (IOException e) {  \n            return false;  \n        } finally {  \n            if (urlConnection != null) {  \n                urlConnection.disconnect();  \n            }  \n        }  \n    }  \n\n    public static void needLoginNetworkCheck(NeedLoginCallBack callBack) {\n        new NetNeedLoginCheckUtil(callBack).execute();\n    }    \n\n    public interface NeedLoginCallBack{\n       void needLogin(boolean needLogin);\n    }\n}\n\n文／李科吐温（简书作者）\n原文链接：http://www.jianshu.com/p/3187c677bca3\n著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。\n","source":"_posts/WiFi-Portal检测.md","raw":"---\ntitle: WiFi Portal检测\ndate: 2017-02-11 21:35:53\ntags: Android\n---\nWiFi连接上一个开放热点，如何判断是否需要登录认证？\n\n首先当我们发送一个request请求时，我们得到的response总是会携带一个HTTP状态码（除非请求超时）。WiFi portal同样也要遵循这样的规则，WiFi portal拦截网络请求时，返回给我们一个response（内容是登陆页面）。我们的这次请求虽然被拦截了，但是无疑他是一个成功的请求，也就是说response携带的状态码应该是 200 。这时，我们与服务器端商定一个请求链接http ://www.xx.com/genera_204，固定返回一个状态码 204。当网络状态发生变化时候，我们就去请求这个链接。如果我们的response携带的状态码是204说明我们请求成功，如果我们得到的是200，说明需要进行WiFi 验证。\n这个方法来自Android4.0.1AOSP源码 WifiWatchdogStateMachine#isWalledGardenConnection()。\n\n对于个人开发者或者“小厂商”不建议在我们自己的服务器上处理http ://www.xxx.com/generate_204，除非你家的服务器很稳定，基本上不出现问题。这时候我们可以考虑下“大厂商”是否已经有类似的功能。像UC啊什么的。他们都能自动提醒你网络需要登陆，他们也是使用了同样的方式，至于链接地址，就靠大家自己了。\n\n代码如下：\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport android.os.AsyncTask;\n/**\n * 检测wifi是否需要登陆\n * 使用方式：\n * NetNeedLoginCheckUtil.needLoginNetworkCheck(new NeedLoginCallBack() {\n *  @Override\n *  public void needLogin(boolean needLogin) {\n *     if (needLogin) {\n *          wifi 需要登陆\n *     }\n *  }\n * });\n **/\n public class NetNeedLoginCheckUtil extends AsyncTask<Integer, Integer, Boolean>{\n    NeedLoginCallBack callBack;\n    public NetNeedLoginCheckUtil(NeedLoginCallBack callBack) {\n        super();\n        this.callBack = callBack;\n    }    \n    @Override\n    protected Boolean doInBackground(Integer... params) {\n        return isWifiSetPortal();\n    }    \n    @Override\n    protected void onPostExecute(Boolean result) {\n        if (callBack != null) {\n            callBack.needLogin(result);\n        }\n    }\n    private boolean isWifiSetPortal() {  \n        final String mWalledGardenUrl = \"http://connect.rom.miui.com/generate_204\";  \n        final int WALLED_GARDEN_SOCKET_TIMEOUT_MS = 10000;  \n        HttpURLConnection urlConnection = null;  \n        try {  \n            URL url = new URL(mWalledGardenUrl);  \n            urlConnection = (HttpURLConnection) url.openConnection();  \n            urlConnection.setInstanceFollowRedirects(false);  \n            urlConnection.setConnectTimeout(WALLED_GARDEN_SOCKET_TIMEOUT_MS);  \n            urlConnection.setReadTimeout(WALLED_GARDEN_SOCKET_TIMEOUT_MS);  \n            urlConnection.setUseCaches(false);  \n            urlConnection.getInputStream();  \n            return urlConnection.getResponseCode() != 204;  \n        } catch (IOException e) {  \n            return false;  \n        } finally {  \n            if (urlConnection != null) {  \n                urlConnection.disconnect();  \n            }  \n        }  \n    }  \n\n    public static void needLoginNetworkCheck(NeedLoginCallBack callBack) {\n        new NetNeedLoginCheckUtil(callBack).execute();\n    }    \n\n    public interface NeedLoginCallBack{\n       void needLogin(boolean needLogin);\n    }\n}\n\n文／李科吐温（简书作者）\n原文链接：http://www.jianshu.com/p/3187c677bca3\n著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。\n","slug":"WiFi-Portal检测","published":1,"updated":"2017-02-11T13:45:03.434Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6yqqxy000dyo2z98u6f4cm","content":"<p>WiFi连接上一个开放热点，如何判断是否需要登录认证？</p>\n<p>首先当我们发送一个request请求时，我们得到的response总是会携带一个HTTP状态码（除非请求超时）。WiFi portal同样也要遵循这样的规则，WiFi portal拦截网络请求时，返回给我们一个response（内容是登陆页面）。我们的这次请求虽然被拦截了，但是无疑他是一个成功的请求，也就是说response携带的状态码应该是 200 。这时，我们与服务器端商定一个请求链接http ://www.xx.com/genera_204，固定返回一个状态码 204。当网络状态发生变化时候，我们就去请求这个链接。如果我们的response携带的状态码是204说明我们请求成功，如果我们得到的是200，说明需要进行WiFi 验证。<br>这个方法来自Android4.0.1AOSP源码 WifiWatchdogStateMachine#isWalledGardenConnection()。</p>\n<p>对于个人开发者或者“小厂商”不建议在我们自己的服务器上处理http ://www.xxx.com/generate_204，除非你家的服务器很稳定，基本上不出现问题。这时候我们可以考虑下“大厂商”是否已经有类似的功能。像UC啊什么的。他们都能自动提醒你网络需要登陆，他们也是使用了同样的方式，至于链接地址，就靠大家自己了。</p>\n<p>代码如下：<br>import java.io.IOException;<br>import java.net.HttpURLConnection;<br>import java.net.URL;<br>import android.os.AsyncTask;<br>/**</p>\n<ul>\n<li>检测wifi是否需要登陆</li>\n<li>使用方式：</li>\n<li>NetNeedLoginCheckUtil.needLoginNetworkCheck(new NeedLoginCallBack() {</li>\n<li>@Override</li>\n<li>public void needLogin(boolean needLogin) {</li>\n<li>if (needLogin) {</li>\n<li>wifi 需要登陆</li>\n<li>}</li>\n<li>}</li>\n<li><p>});<br>**/<br>public class NetNeedLoginCheckUtil extends AsyncTask<integer, integer,=\"\" boolean=\"\">{<br> NeedLoginCallBack callBack;<br> public NetNeedLoginCheckUtil(NeedLoginCallBack callBack) {</integer,></p>\n<pre><code>super();\nthis.callBack = callBack;\n</code></pre><p> }<br> @Override<br> protected Boolean doInBackground(Integer… params) {</p>\n<pre><code>return isWifiSetPortal();\n</code></pre><p> }<br> @Override<br> protected void onPostExecute(Boolean result) {</p>\n<pre><code>if (callBack != null) {\n    callBack.needLogin(result);\n}\n</code></pre><p> }<br> private boolean isWifiSetPortal() {  </p>\n<pre><code>final String mWalledGardenUrl = &quot;http://connect.rom.miui.com/generate_204&quot;;  \nfinal int WALLED_GARDEN_SOCKET_TIMEOUT_MS = 10000;  \nHttpURLConnection urlConnection = null;  \ntry {  \n    URL url = new URL(mWalledGardenUrl);  \n    urlConnection = (HttpURLConnection) url.openConnection();  \n    urlConnection.setInstanceFollowRedirects(false);  \n    urlConnection.setConnectTimeout(WALLED_GARDEN_SOCKET_TIMEOUT_MS);  \n    urlConnection.setReadTimeout(WALLED_GARDEN_SOCKET_TIMEOUT_MS);  \n    urlConnection.setUseCaches(false);  \n    urlConnection.getInputStream();  \n    return urlConnection.getResponseCode() != 204;  \n} catch (IOException e) {  \n    return false;  \n} finally {  \n    if (urlConnection != null) {  \n        urlConnection.disconnect();  \n    }  \n}  \n</code></pre><p> }  </p>\n<p> public static void needLoginNetworkCheck(NeedLoginCallBack callBack) {</p>\n<pre><code>new NetNeedLoginCheckUtil(callBack).execute();\n</code></pre><p> }    </p>\n<p> public interface NeedLoginCallBack{</p>\n<pre><code>void needLogin(boolean needLogin);\n</code></pre><p> }<br>}</p>\n</li>\n</ul>\n<p>文／李科吐温（简书作者）<br>原文链接：<a href=\"http://www.jianshu.com/p/3187c677bca3\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/3187c677bca3</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。</p>\n","excerpt":"","more":"<p>WiFi连接上一个开放热点，如何判断是否需要登录认证？</p>\n<p>首先当我们发送一个request请求时，我们得到的response总是会携带一个HTTP状态码（除非请求超时）。WiFi portal同样也要遵循这样的规则，WiFi portal拦截网络请求时，返回给我们一个response（内容是登陆页面）。我们的这次请求虽然被拦截了，但是无疑他是一个成功的请求，也就是说response携带的状态码应该是 200 。这时，我们与服务器端商定一个请求链接http ://www.xx.com/genera_204，固定返回一个状态码 204。当网络状态发生变化时候，我们就去请求这个链接。如果我们的response携带的状态码是204说明我们请求成功，如果我们得到的是200，说明需要进行WiFi 验证。<br>这个方法来自Android4.0.1AOSP源码 WifiWatchdogStateMachine#isWalledGardenConnection()。</p>\n<p>对于个人开发者或者“小厂商”不建议在我们自己的服务器上处理http ://www.xxx.com/generate_204，除非你家的服务器很稳定，基本上不出现问题。这时候我们可以考虑下“大厂商”是否已经有类似的功能。像UC啊什么的。他们都能自动提醒你网络需要登陆，他们也是使用了同样的方式，至于链接地址，就靠大家自己了。</p>\n<p>代码如下：<br>import java.io.IOException;<br>import java.net.HttpURLConnection;<br>import java.net.URL;<br>import android.os.AsyncTask;<br>/**</p>\n<ul>\n<li>检测wifi是否需要登陆</li>\n<li>使用方式：</li>\n<li>NetNeedLoginCheckUtil.needLoginNetworkCheck(new NeedLoginCallBack() {</li>\n<li>@Override</li>\n<li>public void needLogin(boolean needLogin) {</li>\n<li>if (needLogin) {</li>\n<li>wifi 需要登陆</li>\n<li>}</li>\n<li>}</li>\n<li><p>});<br>**/<br>public class NetNeedLoginCheckUtil extends AsyncTask<Integer, Integer, Boolean>{<br> NeedLoginCallBack callBack;<br> public NetNeedLoginCheckUtil(NeedLoginCallBack callBack) {</p>\n<pre><code>super();\nthis.callBack = callBack;\n</code></pre><p> }<br> @Override<br> protected Boolean doInBackground(Integer… params) {</p>\n<pre><code>return isWifiSetPortal();\n</code></pre><p> }<br> @Override<br> protected void onPostExecute(Boolean result) {</p>\n<pre><code>if (callBack != null) {\n    callBack.needLogin(result);\n}\n</code></pre><p> }<br> private boolean isWifiSetPortal() {  </p>\n<pre><code>final String mWalledGardenUrl = &quot;http://connect.rom.miui.com/generate_204&quot;;  \nfinal int WALLED_GARDEN_SOCKET_TIMEOUT_MS = 10000;  \nHttpURLConnection urlConnection = null;  \ntry {  \n    URL url = new URL(mWalledGardenUrl);  \n    urlConnection = (HttpURLConnection) url.openConnection();  \n    urlConnection.setInstanceFollowRedirects(false);  \n    urlConnection.setConnectTimeout(WALLED_GARDEN_SOCKET_TIMEOUT_MS);  \n    urlConnection.setReadTimeout(WALLED_GARDEN_SOCKET_TIMEOUT_MS);  \n    urlConnection.setUseCaches(false);  \n    urlConnection.getInputStream();  \n    return urlConnection.getResponseCode() != 204;  \n} catch (IOException e) {  \n    return false;  \n} finally {  \n    if (urlConnection != null) {  \n        urlConnection.disconnect();  \n    }  \n}  \n</code></pre><p> }  </p>\n<p> public static void needLoginNetworkCheck(NeedLoginCallBack callBack) {</p>\n<pre><code>new NetNeedLoginCheckUtil(callBack).execute();\n</code></pre><p> }    </p>\n<p> public interface NeedLoginCallBack{</p>\n<pre><code>void needLogin(boolean needLogin);\n</code></pre><p> }<br>}</p>\n</li>\n</ul>\n<p>文／李科吐温（简书作者）<br>原文链接：<a href=\"http://www.jianshu.com/p/3187c677bca3\">http://www.jianshu.com/p/3187c677bca3</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。</p>\n"},{"title":"Ubuntu下使用Hexo创建Gitbub博客","date":"2017-01-05T06:06:55.000Z","_content":"1.环境配置\n安装 node.js : $sudo apt install nodejs-legacy\n安装 npm ： $sudo apt install npm\n安装 git : $sudo apt-get install git\n安装 hexo ： $sudo npm install hexo -g\n\n2.注册github帐号，并创建仓库（注意仓库必须以 “用户名.github.io”）\n\n3.初始化博客，命令行输入下列命令：\n$git init\n$git remote add origin \"git url\"\n$git pull origin master\n\n$hexo init\n$hexo s -g #预览\n\n编辑根目录下的_config.yml 末尾添加下列代码:\n  deploy:\n  type: git\n  repository: https://github.com/AndWong/AndWong.github.io.git\n  branch: master\n\n$npm install hexo-deployer-git --save\n$hexo clean\n$hexo d -g #发布\n\n4.访问 https://andwong.github.io/ #查看\n\n「疑问 : 换台电脑后如何发布博客?」\n上述步骤执行完后master主支就有相应的内容,\n此时新建一个分支blog用于存放博客内容,\n新设备只需pull blog分支修改博客并push就行.\n如果$hexo d -g 失败可以尝试删除根目录下的.deploy_git目录再执行$hexo d -g\n\n————–分割线————\n在_config.yml中修改:\ntitle: Wong Blog #修改页面标题\nauthor: Wong #修改作者\ntheme: hexo-theme-aiki #修改主题样式\n","source":"_posts/gitbub-blog.md","raw":"---\ntitle: Ubuntu下使用Hexo创建Gitbub博客\ndate: 2017-01-05 14:06:55\ntags: github\n---\n1.环境配置\n安装 node.js : $sudo apt install nodejs-legacy\n安装 npm ： $sudo apt install npm\n安装 git : $sudo apt-get install git\n安装 hexo ： $sudo npm install hexo -g\n\n2.注册github帐号，并创建仓库（注意仓库必须以 “用户名.github.io”）\n\n3.初始化博客，命令行输入下列命令：\n$git init\n$git remote add origin \"git url\"\n$git pull origin master\n\n$hexo init\n$hexo s -g #预览\n\n编辑根目录下的_config.yml 末尾添加下列代码:\n  deploy:\n  type: git\n  repository: https://github.com/AndWong/AndWong.github.io.git\n  branch: master\n\n$npm install hexo-deployer-git --save\n$hexo clean\n$hexo d -g #发布\n\n4.访问 https://andwong.github.io/ #查看\n\n「疑问 : 换台电脑后如何发布博客?」\n上述步骤执行完后master主支就有相应的内容,\n此时新建一个分支blog用于存放博客内容,\n新设备只需pull blog分支修改博客并push就行.\n如果$hexo d -g 失败可以尝试删除根目录下的.deploy_git目录再执行$hexo d -g\n\n————–分割线————\n在_config.yml中修改:\ntitle: Wong Blog #修改页面标题\nauthor: Wong #修改作者\ntheme: hexo-theme-aiki #修改主题样式\n","slug":"gitbub-blog","published":1,"updated":"2017-02-12T13:35:28.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6yqqz3000kyo2zfyge2mcd","content":"<p>1.环境配置<br>安装 node.js : $sudo apt install nodejs-legacy<br>安装 npm ： $sudo apt install npm<br>安装 git : $sudo apt-get install git<br>安装 hexo ： $sudo npm install hexo -g</p>\n<p>2.注册github帐号，并创建仓库（注意仓库必须以 “用户名.github.io”）</p>\n<p>3.初始化博客，命令行输入下列命令：<br>$git init<br>$git remote add origin “git url”<br>$git pull origin master</p>\n<p>$hexo init<br>$hexo s -g #预览</p>\n<p>编辑根目录下的_config.yml 末尾添加下列代码:<br>  deploy:<br>  type: git<br>  repository: <a href=\"https://github.com/AndWong/AndWong.github.io.git\" target=\"_blank\" rel=\"external\">https://github.com/AndWong/AndWong.github.io.git</a><br>  branch: master</p>\n<p>$npm install hexo-deployer-git –save<br>$hexo clean<br>$hexo d -g #发布</p>\n<p>4.访问 <a href=\"https://andwong.github.io/\" target=\"_blank\" rel=\"external\">https://andwong.github.io/</a> #查看</p>\n<p>「疑问 : 换台电脑后如何发布博客?」<br>上述步骤执行完后master主支就有相应的内容,<br>此时新建一个分支blog用于存放博客内容,<br>新设备只需pull blog分支修改博客并push就行.<br>如果$hexo d -g 失败可以尝试删除根目录下的.deploy_git目录再执行$hexo d -g</p>\n<p>————–分割线————<br>在_config.yml中修改:<br>title: Wong Blog #修改页面标题<br>author: Wong #修改作者<br>theme: hexo-theme-aiki #修改主题样式</p>\n","excerpt":"","more":"<p>1.环境配置<br>安装 node.js : $sudo apt install nodejs-legacy<br>安装 npm ： $sudo apt install npm<br>安装 git : $sudo apt-get install git<br>安装 hexo ： $sudo npm install hexo -g</p>\n<p>2.注册github帐号，并创建仓库（注意仓库必须以 “用户名.github.io”）</p>\n<p>3.初始化博客，命令行输入下列命令：<br>$git init<br>$git remote add origin “git url”<br>$git pull origin master</p>\n<p>$hexo init<br>$hexo s -g #预览</p>\n<p>编辑根目录下的_config.yml 末尾添加下列代码:<br>  deploy:<br>  type: git<br>  repository: <a href=\"https://github.com/AndWong/AndWong.github.io.git\">https://github.com/AndWong/AndWong.github.io.git</a><br>  branch: master</p>\n<p>$npm install hexo-deployer-git –save<br>$hexo clean<br>$hexo d -g #发布</p>\n<p>4.访问 <a href=\"https://andwong.github.io/\">https://andwong.github.io/</a> #查看</p>\n<p>「疑问 : 换台电脑后如何发布博客?」<br>上述步骤执行完后master主支就有相应的内容,<br>此时新建一个分支blog用于存放博客内容,<br>新设备只需pull blog分支修改博客并push就行.<br>如果$hexo d -g 失败可以尝试删除根目录下的.deploy_git目录再执行$hexo d -g</p>\n<p>————–分割线————<br>在_config.yml中修改:<br>title: Wong Blog #修改页面标题<br>author: Wong #修改作者<br>theme: hexo-theme-aiki #修改主题样式</p>\n"},{"title":"Android中Handler的简单终结","date":"2017-02-12T13:37:59.000Z","_content":"1.Handler何用？\n在实际开发中Handler是为了解决在子线程更新UI的问题。\n\n2.Handler，Looper，MessageQueue的创建？\n一个Handler通常和一个Looper和一个MessageQueue绑定在一起。\n在线程中创建一个Handler时通常会同时创建一个Looper（通过Looper.prepare()为当前线程创建一个Looper,\n并使用Looper.loop()来开启消息的读取）及MessageQueue（创建Looper的同时创建），\n而平时我们在主线程中创建Handler却可以省略该步骤主要是由于主线程在开启时就已自动Looper，\n可以通过getMainLooper()来获取主线程的Looper。\n\n3.Looper,Handler,MessageQueue的引用关系?\nLooper：好比一个泵，循环不断的在MessageQueue中查询消息\nMessageQueue：消息池，用于存放消息\n\n一个线程对应只有一个Looper和一个MessageQueue，但可以有多个Handler。\n\n子线程创建一条MSG通过Handler发送消息到主线程的MessageQueue中，\n主线程对应的Looper循环不断的在MessageQueue中查询MSG，\n查询到则主线程通过Hanler处理消息。\n\n4.Handler导致内存泄露问题?\n一般我们写Handler:\nHandler mHandler = new Handler() {\n@Override\npublic void handleMessage(Message msg) {\n  }\n}\n\n当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有一个外部类对象（通常是一个Activity）的引用,而常常在Activity退出后，消息队列还有未被处理完的消息，此时activity依然被handler引用，导致内存无法回收而内存泄露。\n\n解决方法：\n在Handler中增加一个对Activity的弱引用（WeakReference）：\nstatic class MyHandler extends Handler {\nWeakReference mActivityReference;\n\nMyHandler(Activity activity) {\nmActivityReference= new WeakReference(activity);\n}\n\n@Override\npublic void handleMessage(Message msg) {\nfinal Activity activity = mActivityReference.get();\nif (activity != null) {\n    }\n  }\n}\n\n对于上面的代码，用户在关闭Activity之后，就算后台线程还没结束，但由于仅有一条来自Handler的弱引用指向Activity，所以GC仍然会在检查的时候把Activity回收掉。这样，内存泄露的问题就不会出现了。\n","source":"_posts/Android中Handler的简单终结.md","raw":"---\ntitle: Android中Handler的简单终结\ndate: 2017-02-12 21:37:59\ntags: Android\n---\n1.Handler何用？\n在实际开发中Handler是为了解决在子线程更新UI的问题。\n\n2.Handler，Looper，MessageQueue的创建？\n一个Handler通常和一个Looper和一个MessageQueue绑定在一起。\n在线程中创建一个Handler时通常会同时创建一个Looper（通过Looper.prepare()为当前线程创建一个Looper,\n并使用Looper.loop()来开启消息的读取）及MessageQueue（创建Looper的同时创建），\n而平时我们在主线程中创建Handler却可以省略该步骤主要是由于主线程在开启时就已自动Looper，\n可以通过getMainLooper()来获取主线程的Looper。\n\n3.Looper,Handler,MessageQueue的引用关系?\nLooper：好比一个泵，循环不断的在MessageQueue中查询消息\nMessageQueue：消息池，用于存放消息\n\n一个线程对应只有一个Looper和一个MessageQueue，但可以有多个Handler。\n\n子线程创建一条MSG通过Handler发送消息到主线程的MessageQueue中，\n主线程对应的Looper循环不断的在MessageQueue中查询MSG，\n查询到则主线程通过Hanler处理消息。\n\n4.Handler导致内存泄露问题?\n一般我们写Handler:\nHandler mHandler = new Handler() {\n@Override\npublic void handleMessage(Message msg) {\n  }\n}\n\n当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有一个外部类对象（通常是一个Activity）的引用,而常常在Activity退出后，消息队列还有未被处理完的消息，此时activity依然被handler引用，导致内存无法回收而内存泄露。\n\n解决方法：\n在Handler中增加一个对Activity的弱引用（WeakReference）：\nstatic class MyHandler extends Handler {\nWeakReference mActivityReference;\n\nMyHandler(Activity activity) {\nmActivityReference= new WeakReference(activity);\n}\n\n@Override\npublic void handleMessage(Message msg) {\nfinal Activity activity = mActivityReference.get();\nif (activity != null) {\n    }\n  }\n}\n\n对于上面的代码，用户在关闭Activity之后，就算后台线程还没结束，但由于仅有一条来自Handler的弱引用指向Activity，所以GC仍然会在检查的时候把Activity回收掉。这样，内存泄露的问题就不会出现了。\n","slug":"Android中Handler的简单终结","published":1,"updated":"2017-02-12T14:30:53.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciz6yqqz5000lyo2zfay9r13y","content":"<p>1.Handler何用？<br>在实际开发中Handler是为了解决在子线程更新UI的问题。</p>\n<p>2.Handler，Looper，MessageQueue的创建？<br>一个Handler通常和一个Looper和一个MessageQueue绑定在一起。<br>在线程中创建一个Handler时通常会同时创建一个Looper（通过Looper.prepare()为当前线程创建一个Looper,<br>并使用Looper.loop()来开启消息的读取）及MessageQueue（创建Looper的同时创建），<br>而平时我们在主线程中创建Handler却可以省略该步骤主要是由于主线程在开启时就已自动Looper，<br>可以通过getMainLooper()来获取主线程的Looper。</p>\n<p>3.Looper,Handler,MessageQueue的引用关系?<br>Looper：好比一个泵，循环不断的在MessageQueue中查询消息<br>MessageQueue：消息池，用于存放消息</p>\n<p>一个线程对应只有一个Looper和一个MessageQueue，但可以有多个Handler。</p>\n<p>子线程创建一条MSG通过Handler发送消息到主线程的MessageQueue中，<br>主线程对应的Looper循环不断的在MessageQueue中查询MSG，<br>查询到则主线程通过Hanler处理消息。</p>\n<p>4.Handler导致内存泄露问题?<br>一般我们写Handler:<br>Handler mHandler = new Handler() {<br>@Override<br>public void handleMessage(Message msg) {<br>  }<br>}</p>\n<p>当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有一个外部类对象（通常是一个Activity）的引用,而常常在Activity退出后，消息队列还有未被处理完的消息，此时activity依然被handler引用，导致内存无法回收而内存泄露。</p>\n<p>解决方法：<br>在Handler中增加一个对Activity的弱引用（WeakReference）：<br>static class MyHandler extends Handler {<br>WeakReference mActivityReference;</p>\n<p>MyHandler(Activity activity) {<br>mActivityReference= new WeakReference(activity);<br>}</p>\n<p>@Override<br>public void handleMessage(Message msg) {<br>final Activity activity = mActivityReference.get();<br>if (activity != null) {<br>    }<br>  }<br>}</p>\n<p>对于上面的代码，用户在关闭Activity之后，就算后台线程还没结束，但由于仅有一条来自Handler的弱引用指向Activity，所以GC仍然会在检查的时候把Activity回收掉。这样，内存泄露的问题就不会出现了。</p>\n","excerpt":"","more":"<p>1.Handler何用？<br>在实际开发中Handler是为了解决在子线程更新UI的问题。</p>\n<p>2.Handler，Looper，MessageQueue的创建？<br>一个Handler通常和一个Looper和一个MessageQueue绑定在一起。<br>在线程中创建一个Handler时通常会同时创建一个Looper（通过Looper.prepare()为当前线程创建一个Looper,<br>并使用Looper.loop()来开启消息的读取）及MessageQueue（创建Looper的同时创建），<br>而平时我们在主线程中创建Handler却可以省略该步骤主要是由于主线程在开启时就已自动Looper，<br>可以通过getMainLooper()来获取主线程的Looper。</p>\n<p>3.Looper,Handler,MessageQueue的引用关系?<br>Looper：好比一个泵，循环不断的在MessageQueue中查询消息<br>MessageQueue：消息池，用于存放消息</p>\n<p>一个线程对应只有一个Looper和一个MessageQueue，但可以有多个Handler。</p>\n<p>子线程创建一条MSG通过Handler发送消息到主线程的MessageQueue中，<br>主线程对应的Looper循环不断的在MessageQueue中查询MSG，<br>查询到则主线程通过Hanler处理消息。</p>\n<p>4.Handler导致内存泄露问题?<br>一般我们写Handler:<br>Handler mHandler = new Handler() {<br>@Override<br>public void handleMessage(Message msg) {<br>  }<br>}</p>\n<p>当使用内部类（包括匿名类）来创建Handler的时候，Handler对象会隐式地持有一个外部类对象（通常是一个Activity）的引用,而常常在Activity退出后，消息队列还有未被处理完的消息，此时activity依然被handler引用，导致内存无法回收而内存泄露。</p>\n<p>解决方法：<br>在Handler中增加一个对Activity的弱引用（WeakReference）：<br>static class MyHandler extends Handler {<br>WeakReference mActivityReference;</p>\n<p>MyHandler(Activity activity) {<br>mActivityReference= new WeakReference(activity);<br>}</p>\n<p>@Override<br>public void handleMessage(Message msg) {<br>final Activity activity = mActivityReference.get();<br>if (activity != null) {<br>    }<br>  }<br>}</p>\n<p>对于上面的代码，用户在关闭Activity之后，就算后台线程还没结束，但由于仅有一条来自Handler的弱引用指向Activity，所以GC仍然会在检查的时候把Activity回收掉。这样，内存泄露的问题就不会出现了。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ciz6yqqx60004yo2z8fbdy6gu","tag_id":"ciz6yqqwt0002yo2zorbm8zwy","_id":"ciz6yqqxj0007yo2zvjqrkhw5"},{"post_id":"ciz6yqqwb0000yo2zln1v86fm","tag_id":"ciz6yqqwt0002yo2zorbm8zwy","_id":"ciz6yqqxp0009yo2ze2xrej9d"},{"post_id":"ciz6yqqxb0005yo2zbvs4alww","tag_id":"ciz6yqqwt0002yo2zorbm8zwy","_id":"ciz6yqqxw000cyo2ztn6yskbz"},{"post_id":"ciz6yqqxk0008yo2zn5jdaluj","tag_id":"ciz6yqqwt0002yo2zorbm8zwy","_id":"ciz6yqqy1000eyo2zwuxo036c"},{"post_id":"ciz6yqqwn0001yo2z3b3ut6vl","tag_id":"ciz6yqqwt0002yo2zorbm8zwy","_id":"ciz6yqqy2000gyo2zkpnjk1yz"},{"post_id":"ciz6yqqxy000dyo2z98u6f4cm","tag_id":"ciz6yqqwt0002yo2zorbm8zwy","_id":"ciz6yqqy3000hyo2z3b8qtscd"},{"post_id":"ciz6yqqwz0003yo2zbagpsvtv","tag_id":"ciz6yqqwt0002yo2zorbm8zwy","_id":"ciz6yqqy3000iyo2zgoz902fc"},{"post_id":"ciz6yqqxq000ayo2zoc84y6c5","tag_id":"ciz6yqqy1000fyo2z9phw4i75","_id":"ciz6yqqy5000jyo2zowhotz3d"},{"post_id":"ciz6yqqz5000lyo2zfay9r13y","tag_id":"ciz6yqqwt0002yo2zorbm8zwy","_id":"ciz6yqqzd000nyo2z4bpsh8st"},{"post_id":"ciz6yqqz3000kyo2zfyge2mcd","tag_id":"ciz6yqqz8000myo2z0ue4s8ze","_id":"ciz6yqqzl000oyo2zh1mqzads"}],"Tag":[{"name":"Android","_id":"ciz6yqqwt0002yo2zorbm8zwy"},{"name":"四大组件之Activity","_id":"ciz6yqqy1000fyo2z9phw4i75"},{"name":"github","_id":"ciz6yqqz8000myo2z0ue4s8ze"}]}}